# systems/axon/schemas.py

from typing import Literal

from pydantic import BaseModel, Field


class AxonEvent(BaseModel):
    """
    The fundamental unit of sensory information flowing from Axon to Atune.
    Represents a single, atomic observation of the external world.
    """

    event_id: str = Field(..., description="Unique identifier for the event.")
    t_observed: float = Field(..., description="UNIX timestamp of observation.")
    source: str = Field(..., description="The origin of the event, e.g., a specific driver.")
    event_type: str = Field(..., description="Categorical type of the event.")
    modality: Literal[
        "text",
        "html",
        "json",
        "audio",
        "video",
        "image",
        "tabular",
        "graph",
        "binary",
    ]
    payload_ref: str | None = Field(
        None,
        description="Reference to the raw payload, if stored separately.",
    )
    parsed: dict | None = Field(None, description="The structured, parsed content of the event.")
    embeddings: dict[str, list[float]] = Field(
        default_factory=dict,
        description="Embeddings for various aspects of the event.",
    )
    provenance: dict = Field(..., description="Traceable origin: driver_id, version, checksums.")
    salience_hints: dict = Field(
        default_factory=dict,
        description="Initial fast-computed hints for Atune's FAE.",
    )
    quality: dict = Field(default_factory=dict, description="Metrics on the data quality.")
    triangulation: dict = Field(
        default_factory=dict,
        description="Cross-corroboration and contradiction flags.",
    )
    cost_ms: int | None = Field(None, description="Milliseconds taken to generate this event.")
    cost_usd: float | None = Field(None, description="Estimated USD cost to generate this event.")


class AxonIntent(BaseModel):
    """
    A validated, resourced, and authorized intention to act in the world.
    This is sent from Atune/Synapse to Axon for execution.
    """

    intent_id: str = Field(..., description="Unique identifier for the intent.")
    purpose: str = Field(..., description="Plain-language reason for the action, for auditability.")
    target_capability: str = Field(
        ...,
        description="The specific capability this intent invokes, e.g., 'twitter:post_tweet'.",
    )
    params: dict = Field(..., description="The parameters for the capability.")
    risk_tier: Literal["low", "mid", "high", "extreme"]
    constraints: dict = Field(
        ...,
        description="Operational constraints, e.g., max_retries, timeout_ms.",
    )
    policy_trace: dict = Field(
        ...,
        description="Chain of decisions: synapse_plan_hash, unity_verdict, equor_cap_token.",
    )
    rollback_contract: dict = Field(
        ...,
        description="A description of how to undo or neutralize this action.",
    )


class ActionResult(BaseModel):
    """
    The measured result of executing an AxonIntent. This closes the loop.
    """

    intent_id: str = Field(..., description="The ID of the intent that was executed.")
    status: Literal["ok", "fail", "blocked"]
    outputs: dict = Field(..., description="The direct outputs from the driver execution.")
    side_effects: dict = Field(..., description="Observed, indirect consequences of the action.")
    counterfactual_metrics: dict = Field(
        ...,
        description="Metrics comparing the outcome to the Simula twin's prediction.",
    )
    follow_up_events: list[str] = Field(
        default_factory=list,
        description="IDs of new AxonEvents generated by this action.",
    )
